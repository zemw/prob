{
  "hash": "21e312981b08076d341e52a350cba0eb",
  "result": {
    "engine": "knitr",
    "markdown": "## Two envelope paradox\n\n::: {#exm-two-envelope}\n### Two-envelope paradox\n\nImagine you are given two identical envelopes, each containing money.\nOne contains twice as much as the other. You may pick one envelope and\nkeep the money it contains. Having chosen an envelope at will, but\nbefore inspecting it, you are given the chance to switch envelopes.\nShould you switch?\n:::\n\nThe paradox arises when you try to solve the expectation. Let $A$ denote\nthe amount of money in the envelope you have chosen, and $B$ denote the\namount of money in the other envelope.\n\nWe know $B$ is either twice as much as $A$, or half as much as $A$. Each\nwith probability $1/2$. So\n\n$$E(B) = \\frac{1}{2}(2A) + \\frac{1}{2}(A/2) = \\frac{5}{4}A$$\n\nSince $E(B)>A$, you should always switch! However, after you switch to\n$B$, by the same argument, you should switch back to $A$. You you switch\nback and forth indefinitely!\n\n**Where do things go wrong?** The error in this calculation lies in a\nsubtle misunderstanding: the two $A$s in the calculation actually\nrepresent different values, that are incorrectly equated. In particular,\nthe $2A$ represents the expected value in the other envelope given that\nit is the larger one, and the $A/2$ represents the expected value in the\nother envelope given that it is the smaller one.\n\n$$E(B) = E(B|B<A)P(B<A) + E(B|B>A)P(B>A)$$\n\nSuppose the amount of money in the two envelopes are $a$ and $2a$\nrespectively. $E(B|B<A)=a$ and $E(B|B>A)=2a$. Therefore,\n\n$$E(B)=\\frac{1}{2}a + \\frac{1}{2}2a = \\frac{3}{2}a.$$\n\nThe same calculation applies to $E(A)$. Thus, $E(A)=E(B)$.\n\n::: {#exm-hh-ht}\n### HH vs HT\n\nFlip a coin indefinite times. Let $X$ denote the number of flips until\nyou see HH. Let $Y$ denote the number of flips until you see HT. Find\n$E(X)$ and $E(Y)$.\n:::\n\nIt is tempting to think they are the same, since either H or T happens\nwith probability 1/2. But the answer is extremely counter-intuitive:\n$E(X)>E(Y)$!\n\n**HH case.** Let $E_0$ = E(X\\|No H observed), and $E_1$ = E(X\\|One H\nobserved). Then $$E_0 = 1 + \\frac{1}{2}E_1 + \\frac{1}{2}E_0$$\n\nThe first term is we need to flip once. If the first flip is H, the\nadditional expected number of flips is $E_1$. If the first flip is T, we\nhave to start over again ($E_0$).\n\n$$E_1 = 1 + \\frac{1}{2}(0) + \\frac{1}{2}E_0$$\n\nOnce we have observed an H, we do another flip. If it is another H, we\nare done. If it is a T, we have to start over again ($E_0$).\n\nSolve the two equations, we have $E_0=6$, $E_1=4$. Thus, $E(X)=6$.\n\n**HT case.** Let $E_0$ = E(Y\\|No H observed), and $E_1$ = E(Y\\|One H\nobserved). Then\n\n$$E_0 = 1 + \\frac{1}{2}E_1 + \\frac{1}{2}E_0$$\n\nIf the first flip is H, we need $E_1$. If the first flip is T, we have\nwasted the flip, so it is $E_0$ again.\n\n$$E_1 = 1 + \\frac{1}{2}(0) + \\frac{1}{2}E_1$$\n\nIf we have a T by 1/2 chance, we are done (the first term). If it is an\nH, we get another $E_1$.\n\nIn this case, we have $E_0=4$, $E_1=2$. Thus, $E(Y)=4$.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Function to simulate the number of flips until a specific pattern appears\nsimulate_pattern <- function(pattern, n_simulations) {\n  results <- numeric(n_simulations)\n  \n  for (i in 1:n_simulations) {\n    flips <- character(0)  # Initialize an empty vector to store flips\n    count <- 0  # Initialize the flip counter\n    \n    while (TRUE) {\n      # Simulate a coin flip (H or T)\n      flip <- sample(c(\"H\", \"T\"), 1)\n      flips <- c(flips, flip)  # Append the flip to the sequence\n      count <- count + 1  # Increment the flip counter\n      \n      # Check if the last two flips match the pattern\n      if (length(flips) >= 2 && all(tail(flips, 2) == pattern)) {\n        results[i] <- count  # Record the number of flips\n        break  # Exit the loop\n      }\n    }\n  }\n  \n  return(results)\n}\n\n# Set the number of simulations\nn_simulations <- 2000\n\n# Simulate for HH\nresults_HH <- simulate_pattern(c(\"H\", \"H\"), n_simulations)\nexpected_HH <- mean(results_HH)\n\n# Simulate for HT\nresults_HT <- simulate_pattern(c(\"H\", \"T\"), n_simulations)\nexpected_HT <- mean(results_HT)\n\n# Create a table of results\nresults_table <- data.frame(\n  Pattern = c(\"HH\", \"HT\"),\n  Expected_Flips = c(expected_HH, expected_HT)\n)\n\n# Print the table\nknitr::kable(results_table)\n```\n\n::: {.cell-output-display}\n\n\n|Pattern | Expected_Flips|\n|:-------|--------------:|\n|HH      |          5.916|\n|HT      |          4.018|\n\n\n:::\n:::\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}